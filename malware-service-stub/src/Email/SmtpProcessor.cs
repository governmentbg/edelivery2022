// Copyright (c) 2003, Eric Daugherty (http://www.ericdaugherty.com)
// All rights reserved.
// Modified by Carlos Mendible
using System;
using System.Collections.Concurrent;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.Extensions.Logging;

namespace MalwareServiceStub
{
    /// <summary>
    /// SMTPProcessor handles a single SMTP client connection. This
    /// class provides an implementation of the RFC821 specification.
    /// </summary>
    /// <remarks>
    ///     Created by: Eric Daugherty
    ///     Modified by: Carlos Mendible
    /// </remarks>
    public class SmtpProcessor
    {
        /// <summary>DATA Comand</summary>
#pragma warning disable CA1707 // Identifiers should not contain underscores
        public const int COMMAND_DATA = 6;

        // Command codes
        /// <summary>HELO Command</summary>
        public const int COMMAND_HELO = 0;

        /// <summary>MAIL FROM Command</summary>
        public const int COMMAND_MAIL = 4;

        /// <summary>NOOP Command</summary>
        public const int COMMAND_NOOP = 2;

        /// <summary>QUIT Command</summary>
        public const int COMMAND_QUIT = 3;

        /// <summary>RCPT TO Command</summary>
        public const int COMMAND_RCPT = 5;

        /// <summary>RSET Command</summary>
        public const int COMMAND_RSET = 1;
#pragma warning restore CA1707 // Identifiers should not contain underscores

        private const string MESSAGE_DEFAULT_HELO_RESPONSE = "250 {0}";

        // Messages
        private const string MESSAGE_DEFAULT_WELCOME = "220 {0} Welcome to C# SMTP Server.";
        private const string MESSAGE_GOODBYE = "221 Goodbye.";
        private const string MESSAGE_INVALID_ADDRESS = "451 Address is invalid.";
        private const string MESSAGE_INVALID_ARGUMENT_COUNT = "501 Incorrect number of arguments.";
        private const string MESSAGE_INVALID_COMMAND_ORDER = "503 Command not allowed here.";
        private const string MESSAGE_OK = "250 OK";
        private const string MESSAGE_START_DATA = "354 Start mail input; end with <CRLF>.<CRLF>";
        private const string MESSAGE_UNKNOWN_COMMAND = "500 Command Unrecognized.";

        // Regular Expressions
        private static readonly Regex ADDRESS_REGEX = new Regex("<.+@.+>", RegexOptions.IgnoreCase);

        /// <summary>
        /// Context holding refenrece to Socket
        /// </summary>
        SmtpContext? context;

        /// <summary>Domain name for this server.</summary>
        private string domain = string.Empty;

        /// <summary>The response to the HELO command.</summary>
        private string heloResponse = string.Empty;

        ILogger<SimpleSmtpServer> log;

        /// <summary>
        /// List of received messages (emails).
        /// </summary>
        ConcurrentBag<SmtpMessage>? smtpMessageStore;

        /// <summary>The message to display to the client when they first connect.</summary>
        private string welcomeMessage = string.Empty;

        /// <summary>
        /// Initializes the SMTPProcessor with the appropriate
        /// interface implementations.  This allows the relay and
        /// delivery behaviour of the SMTPProcessor to be defined
        /// by the specific server.
        /// </summary>
        /// <param name="domain">
        /// The domain name this server handles mail for.  This does not have to
        /// be a valid domain name, but it will be included in the Welcome Message
        /// and HELO response.
        /// </param>
        public SmtpProcessor(string domain, ConcurrentBag<SmtpMessage>? smtpMessageStore, ILogger<SimpleSmtpServer> logger)
        {
            this.smtpMessageStore = smtpMessageStore;
            this.Initialize(domain);
            this.log = logger;
        }

        public event EventHandler<MessageReceivedEventArgs>? MessageReceived;

        /// <summary>
        /// The response to the HELO command.  This response should
        /// include the local server's domain name.  Please refer to RFC 821
        /// for more details.
        /// </summary>
        public virtual string HeloResponse
        {
            get
            {
                return this.heloResponse;
            }

            set
            {
                this.heloResponse = string.Format(value, this.domain);
            }
        }

        /// <summary>
        /// Returns the welcome message to display to new client connections.
        /// This method can be overridden to allow for user defined welcome messages.
        /// Please refer to RFC 821 for the rules on acceptable welcome messages.
        /// </summary>
        public virtual string WelcomeMessage
        {
            get
            {
                return this.welcomeMessage;
            }

            set
            {
                this.welcomeMessage = string.Format(value, this.domain);
            }
        }

        /// <summary>
        /// ProcessConnection handles a connected TCP Client
        /// and performs all necessary interaction with this
        /// client to comply with RFC821.  This method is thread
        /// safe.
        /// </summary>
        public void ProcessConnection(Socket socket)
        {
            this.context = new SmtpContext(socket, this.log);
            this.log.LogDebug("Sending welcome message.");
            this.SendWelcomeMessage(this.context);
            this.log.LogDebug("Welcome message sent.");
            this.log.LogDebug("Processing Commands.");
            this.ProcessCommands(this.context);
            this.log.LogDebug("Done processing Commands.");
        }

        /// <summary>
        /// Stops the processor.
        /// </summary>
        public void Stop()
        {
            if (this.context == null)
            {
                return;
            }

            this.log.LogDebug("trying to stop processor.");
            this.log.LogDebug("Shutting down Socket.");
            this.context.Socket.Shutdown(SocketShutdown.Both);
            this.log.LogDebug("Socket Shutdown.");
            this.log.LogDebug("Closing Socket.");
            this.context.Socket.Close();
            this.log.LogDebug("Socket Closed.");
        }

        private void Data(SmtpContext context)
        {
            context.WriteLine(MESSAGE_START_DATA);

            var rawSmtpMessage = context.Message;

            var clientEndPoint = (IPEndPoint?)context.Socket.RemoteEndPoint;
            var header = new StringBuilder();
            header.Append(string.Format("Received: from ({0} [{1}])", context.ClientDomain, clientEndPoint?.Address));
            header.Append("\r\n");
            header.Append("     " + System.DateTime.Now);
            header.Append("\r\n");

            rawSmtpMessage.Data.Append(header);

            header.Length = 0;

            var line = context.ReadLine();
            while (line is not null && !line.Equals("."))
            {
                rawSmtpMessage.Data.Append(line);
                rawSmtpMessage.Data.Append("\r\n");
                line = context.ReadLine();
            }

            // Spool the message
            if (this.smtpMessageStore is not null)
            {
                lock (this.smtpMessageStore)
                {
                    var smtpMessage = new SmtpMessage(rawSmtpMessage);

                    this.smtpMessageStore.Add(smtpMessage);

                    if (this.MessageReceived is not null)
                    {
                        this.MessageReceived(this, new MessageReceivedEventArgs(smtpMessage));
                    }
                }
            }

            context.WriteLine(MESSAGE_OK);

            // Reset the connection.
            context.Reset();
        }

        /// <summary>
        /// Handles the HELO command.
        /// </summary>
        private void Helo(SmtpContext context, string[] inputs)
        {
            if (context.LastCommand == -1)
            {
                if (inputs.Length == 2)
                {
                    context.ClientDomain = inputs[1];
                    context.LastCommand = COMMAND_HELO;
                    context.WriteLine(this.HeloResponse);
                }
                else
                {
                    context.WriteLine(MESSAGE_INVALID_ARGUMENT_COUNT);
                }
            }
            else
            {
                context.WriteLine(MESSAGE_INVALID_COMMAND_ORDER);
            }
        }

        /// <summary>
        /// Provides common initialization logic for the constructors.
        /// </summary>
        private void Initialize(string domain)
        {
            this.domain = domain;

            // Initialize default messages
            this.welcomeMessage = string.Format(MESSAGE_DEFAULT_WELCOME, domain);
            this.heloResponse = string.Format(MESSAGE_DEFAULT_HELO_RESPONSE, domain);
        }

        /// <summary>
        /// Handle the MAIL FROM:&lt;address&gt; command.
        /// </summary>
        private void Mail(SmtpContext context, string argument)
        {
            var addressValid = false;
            if (context.LastCommand == COMMAND_HELO)
            {
                var address = this.ParseAddress(argument);
                if (!string.IsNullOrEmpty(address))
                {
                    try
                    {
                        // EmailAddress emailAddress = new EmailAddress(address);
                        // context.Message.FromAddress = emailAddress;
                        context.LastCommand = COMMAND_MAIL;
                        addressValid = true;
                        context.WriteLine(MESSAGE_OK);
                    }
#pragma warning disable CA1031 // Do not catch general exception types
                    catch
#pragma warning restore CA1031 // Do not catch general exception types
                    {
                        // This is fine, just fall through.
                    }
                }

                // If the address is invalid, inform the client.
                if (!addressValid)
                {
                    context.WriteLine(MESSAGE_INVALID_ADDRESS);
                }
            }
            else
            {
                context.WriteLine(MESSAGE_INVALID_COMMAND_ORDER);
            }
        }

        /// <summary>
        /// Parses a valid email address out of the input string and return it.
        /// Null is returned if no address is found.
        /// </summary>
        private string ParseAddress(string input)
        {
            var match = ADDRESS_REGEX.Match(input);
            if (match.Success)
            {
                var matchText = match.Value;

                // Trim off the :< chars
                matchText = matchText.Remove(0, 1);

                // trim off the . char.
                matchText = matchText.Remove(matchText.Length - 1, 1);

                return matchText;
            }

            return string.Empty;
        }

        /// <summary>
        /// Handles the command input from the client.  This
        /// message returns when the client issues the quit command.
        /// </summary>
        private void ProcessCommands(SmtpContext context)
        {
            var isRunning = true;

            // Loop until the client quits.
            while (isRunning)
            {
                try
                {
                    var inputLine = context.ReadLine();
                    if (inputLine == null)
                    {
                        isRunning = false;
                        context.WriteLine(MESSAGE_GOODBYE);
                        context.Close();
                        continue;
                    }

                    string[] inputs = inputLine.Split(" ".ToCharArray());

                    switch (inputs[0].ToLower())
                    {
                        case "helo":
                            this.Helo(context, inputs);
                            break;
                        case "ehlo":
                            context.WriteLine("250-{inputs[1]}");
                            context.WriteLine("250 AUTH PLAIN");
                            context.LastCommand = COMMAND_HELO;
                            break;
                        case "rset":
                            this.Rset(context);
                            break;
                        case "noop":
                            context.WriteLine(MESSAGE_OK);
                            break;
                        case "quit":
                            isRunning = false;
                            context.WriteLine(MESSAGE_GOODBYE);
                            context.Close();
                            break;
                        case "mail":
                            if (inputs[1].ToLower().StartsWith("from"))
                            {
                                this.Mail(context, inputLine.Substring(inputLine.IndexOf(" ")));
                                break;
                            }

                            context.WriteLine(MESSAGE_UNKNOWN_COMMAND);
                            break;
                        case "rcpt":
                            if (inputs[1].ToLower().StartsWith("to"))
                            {
                                this.Rcpt(context, inputLine.Substring(inputLine.IndexOf(" ")));
                                break;
                            }

                            context.WriteLine(MESSAGE_UNKNOWN_COMMAND);
                            break;
                        case "data":
                            this.Data(context);
                            break;
                        case "auth":
                            context.WriteLine("235 Authentication successful.");
                            break;
                        default:
                            context.WriteLine(MESSAGE_UNKNOWN_COMMAND);
                            break;
                    }
                }
                catch (SocketException sx)
                {
                    if (sx.ErrorCode == 10060)
                    {
                        context.WriteLine(MESSAGE_GOODBYE);
                    }
                    else
                    {
                        this.log.LogError("Processing exception", sx);
                    }


                    isRunning = false;
                    context.Socket.Dispose();
                }
#pragma warning disable CA1031 // Do not catch general exception types
                catch (Exception)
#pragma warning restore CA1031 // Do not catch general exception types
                {
                    isRunning = false;
                    context.Socket.Dispose();
                }
            }
        }

        /// <summary>
        /// Handle the RCPT TO:&lt;address&gt; command.
        /// </summary>
        private void Rcpt(SmtpContext context, string argument)
        {
            if (context.LastCommand == COMMAND_MAIL || context.LastCommand == COMMAND_RCPT)
            {
                var address = this.ParseAddress(argument);
                if (!string.IsNullOrEmpty(address))
                {
                    try
                    {
                        var emailAddress = new EmailAddress(address);
                        context.Message.AddRecipient(emailAddress);
                        context.LastCommand = COMMAND_RCPT;
                        context.WriteLine(MESSAGE_OK);
                    }
#pragma warning disable CA1031 // Do not catch general exception types
                    catch
#pragma warning restore CA1031 // Do not catch general exception types
                    {
                        context.WriteLine(MESSAGE_INVALID_ADDRESS);
                    }
                }
                else
                {
                    context.WriteLine(MESSAGE_INVALID_ADDRESS);
                }
            }
            else
            {
                context.WriteLine(MESSAGE_INVALID_COMMAND_ORDER);
            }
        }

        /// <summary>
        /// Reset the connection state.
        /// </summary>
        private void Rset(SmtpContext context)
        {
            if (context.LastCommand != -1)
            {
                // Dump the message and reset the context.
                context.Reset();
                context.WriteLine(MESSAGE_OK);
            }
            else
            {
                context.WriteLine(MESSAGE_INVALID_COMMAND_ORDER);
            }
        }

        /// <summary>
        /// Sends the welcome greeting to the client.
        /// </summary>
        private void SendWelcomeMessage(SmtpContext context)
        {
            context.WriteLine(this.WelcomeMessage);
        }
    }
}
