using System;
using System.Collections.Concurrent;
using System.IO;
using System.Security.Cryptography;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Http.Features;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.WebUtilities;
using Microsoft.Extensions.Logging;
using Microsoft.Net.Http.Headers;

namespace MalwareServiceStub
{
    [ApiController]
    public class MalwareServiceController
    {
        private static ConcurrentDictionary<string, (Evaluation evaluation, DateTime arrival)> evaluations = new();
        // Get the default form options so that we can use them to set the default limits for
        // request body data
        private static readonly FormOptions defaultFormOptions = new();

        [HttpPost]
        [DisableFormValueModelBinding]
        [RequestSizeLimit(2 * 1024 * 1024 * 1024L)] // the max file size is 50MB but we give it some slack for headers, etc.
        [Route("eval")]
        public async Task<ActionResult<string>> PostEvalAsync(
            [FromServices]IHttpContextAccessor httpContextAccessor,
            [FromServices]ILogger<MalwareServiceController> logger,
            CancellationToken ct)
        {
            var httpContext = httpContextAccessor.HttpContext!;
            var request = httpContext.Request;
            
            try
            {
                if (!MultipartRequestHelper.IsMultipartContentType(request.ContentType))
                {
                    return new ContentResult
                    {
                        Content = $"Expected a multipart request, but got {request.ContentType}",
                        ContentType = "text/plain",
                        StatusCode = StatusCodes.Status400BadRequest
                    };
                }

                var boundary = MultipartRequestHelper.GetBoundary(
                    MediaTypeHeaderValue.Parse(request.ContentType),
                    defaultFormOptions.MultipartBoundaryLengthLimit);
                var reader = new MultipartReader(boundary, httpContext.Request.Body);

                string? malwareScanId = null;
                var section = await reader.ReadNextSectionAsync(ct);
                while (section != null)
                {
                    if (ContentDispositionHeaderValue.TryParse(section.ContentDisposition, out var contentDisposition) &&
                        MultipartRequestHelper.HasFileContentDisposition(contentDisposition))
                    {
                        string file;
                        if (!string.IsNullOrEmpty(contentDisposition.FileNameStar.Value))
                        {
                            file = contentDisposition.FileNameStar.Value;
                        }
                        else if (!string.IsNullOrEmpty(contentDisposition.FileName.Value))
                        {
                            file = contentDisposition.FileName.Value;
                        }
                        else
                        {
                            throw new Exception("At least one of FileName/FileNameStar should have a value");
                        }

                        string fileName = Path.GetFileName(file);
                        
                        using HashAlgorithm hashAlgorithm = HashAlgorithm.Create("SHA256")!;
                        using (CryptoStream hashStream = new(Stream.Null, hashAlgorithm, CryptoStreamMode.Write))
                        {
                            await section.Body.CopyToAsync(hashStream, ct);
                        }

                        malwareScanId = Guid.NewGuid().ToString();
                        string sha256 = BitConverter.ToString(hashAlgorithm.Hash!).Replace("-", String.Empty);
                        var now = DateTime.Now;
                        // arriving in 300 to 5000 milliseconds
                        //var arrival = now.AddMilliseconds(300 + RandomNumberGenerator.GetInt32(4701));
                        var arrival = now;
                        
                        var evaluation = new Evaluation
                        {
                            Id = malwareScanId,
                            Date = now,
                            StatusDate = now,
                            Files = new EvaluationFile[]
                            {
                                new EvaluationFile
                                {
                                    FileName = fileName,
                                    Sha256 = sha256,
                                    StatusDate = now,
                                }
                            }
                        };

                        logger.LogInformation(
                            $"POST eval {malwareScanId} {sha256}");

                        evaluations.TryAdd(malwareScanId, (evaluation, arrival));

                        // we are looking for the first file and nothing else
                        break;
                    }

                    // Drains any remaining section body that has not been consumed and
                    // reads the headers for the next section.
                    section = await reader.ReadNextSectionAsync(ct);
                }

                return malwareScanId ?? throw new Exception("No file posted.");
            }
            catch (OperationCanceledException)
            {
                logger.LogInformation("Eval canceled");
                return new NoContentResult();
            }
        }

        [HttpGet("eval/{id}")]
        public ActionResult<Evaluation> Get([FromRoute]string id)
        {
            if (!evaluations.TryGetValue(id, out var evaluationAndArrival))
            {
                return new ContentResult
                {
                    Content = $"Cannot find evaluation with id '{id}'",
                    ContentType = "text/plain",
                    StatusCode = StatusCodes.Status404NotFound
                };
            }

            var (evaluation, arrival) = evaluationAndArrival;
            var now = DateTime.Now;
            bool arrived = now > arrival;
            var status = arrived ? EvaluationStatus.Complete : EvaluationStatus.InProgress;
            var statusDate = arrived ? arrival : evaluation.StatusDate;
            var malicious = arrived
                ? evaluation.Files![0].FileName switch
                {
                    "malicious.exe" => true,
                    "failure.exe" => throw new Exception(),
                    _ => false,
                }
                : (bool?)null;

            return evaluation with
            {
                ElapsedTime = now - evaluation.Date,
                Status = status,
                StatusDate = statusDate,
                Malicious = malicious,
                Files = new EvaluationFile[]
                {
                    evaluation.Files![0] with
                    {
                        Status = status,
                        StatusDate = statusDate,
                        Malicious = malicious,
                    }
                }
            };
        }
    }
}